---
layout: post
title: "Computer base"
date: 2022-11-30
categories:
  - Computer
tags:
  - Computer
  - hardware
  - software
  - cpu
  - 입력장치
  - 출력장치
  - 중앙처리장치
  - 레지스터
  - Reduced Instruction Set Computer
  - Complex Instruction Set Computer
  - memory
  - ramdom access memory
  - read only memory
  - cache memory
  - 운영체제
  - 응용프로그램
  - processor
  - process
  - thread
  - 문자열
  - unicode
  - utf-8
  - utf-16
  - ASCll
  - bitmap
  - vector
  - 가비지컬렉션
  - reference counting
  - tracing
  - 메모리 누수
  - event loop
---

콤퓨타 퍼스콤 PC 286부터 시작해서 어릴때 해보고 싶었던 다마고치부터 요새는 누구나 한개이상은 가지고 있다는 스마트폰까지.

---

## 1. 컴퓨터 구조

hardware + software

- hardware: 전자회로 및 기계장치로 되어있는 입출력 장치, cpu, 기억장치 등 구성
- software: hardware 제어하며 작업 수행하는 pg

### 1.1. 기본 구조

- 입력 장치: 컴퓨터가 처리할 수 있는 형태로 데이터와 명령을 받는 물리적 장치, 컴퓨터에 연결해 무언가를 입력할 수 있는 장치
- 출력 장치: 처리된 데이터를 사람이 이해할 수 있는 형태로 출력하는 물리적인 장치
- 중앙처리장치: cpu, 산술/논리 연산장치 alu, 제어장치, 레지스터로 구성되어 있다.
  - 산술: 덧샘 수행
  - 제어: pg에 따른 명령과 제어 신호 생성, 각 장치의 동작을 제어함.
  - 레지스터: cpu 내부 메모리로 cpu에서 사용하는 데이터를 일시적으로 저장하는 장소이다.
- 저장 장치: 데이터나 프로그램을 보관하기 위한 1차 기억장치인 Memory, 주 기억장치를 보조하는 disk, cd와 같은 보조 기억장치가 있다.
  - cpu의 레지스터가 가장 빠르지만 용량이 적어, 주기억장치를 두어 필요시마다 cpu의 레지스터로 올린다. ram과 rom이 있다.
  - cpu의 레지스터, ram, rom보다 느리지만 대용량으로 기록이 가능한 보조 기억장치가 존재한다. 일반적으로 우리가 많이 사용하는 ssd, hdd, sdcard 등 과거 플로피 디스크도 해당되는 저장장치

### 1.2. cpu

수학은 이해하는것이아니라 익숙해져야한다고 말한 현대 컴퓨터의 기초를 다진 노이만선생님은 중앙처리장치인 cpu를 통해 연산을 수행하게 구조를 제안하였다. 중앙처리장치는 연산을 수행하고, 기억장치에 기억되어있는 명령어들을 수행한다.

#### 1.2.1. 구조

```
레지스터  ↔ ↔ ↔ ↔ ↔
  ↑↓            제어장치
연산장치(ALU) ↔ ↔ ↔
```

산술/놀리연산장치(ALU), 제어장치와 레지스터로 구성되어있다.

##### 1.2.1.1. 산술/논리 연산장치

Arithmetic Logic Unit, ALU는 산술 연산과 논리 연산을 담담하는 장치로 가산, 보수, 누산, 기억 레지스터, 데이터 레지스터로 구성된다. 캐시나 메모리로부터 읽어 온 데이터는 레지스터(CPU전용 기억장소)에 저장되고, ALU는 레지스터에 저장된 데이터를 이용해 산술연산을 수행한다. 부동소숫연산장치인 FPU와 정수연산장치, 논리연산(AND, OR, 등)장치 등이 있다.

##### 1.2.1.2. 레지스터

Register는 CPU 내부에 있는 기억장치로 산술 연산 논리장치에 의해 사용되는 범용 레지스터(General-Purpose Register)와 특수목적에 사용되는 전용 레지스터(Dedicated-Purpose Register)가 있다.

- Instruction Register(IR): 현재 수행중에 있는 명령어 부호를 저장한다.
- Program Counter(PC): 명령이 저장된 메모리의 주소를 가르킨다.
- Accumulator(AC): 산술 및 논리 연산의 결과를 임시로 기억한다.

##### 1.2.1.3. 제어장치

Control Unit(CU)은 CPU가 장치의 주변기기를 컨트롤하는 장치이다.

- program counter: 프로그램의 수행 순서를 제어하는 프로그램 계수기
- instruction register: 현재 수행중인 명령어의 내용을 임시 기억하는 명령 레지스터
- insttruction decoder: 명령레지스터에 수록된 명령을 해독해 수행할 장치에 제어신호를 보내는 명령해독기가 있다.

|           | Hardwired                                                                                                                     | Micro Program                                                                                              |
| --------- | ----------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| 설명      | 제어신호가 Hardwired Circuit에 의해 생성되도록 하드웨어를 구성하며, 상태계수기와 ProgrammableLogic Array, PLA회로로 구성된다. | 발생 가능한 제어 신호들의 조합을 미리 구성하여 ROM에 저정했다 필요할때 신호를 발생시키는 software방식이다. |
| 속도/비용 | 고속 처리이고 고가이다.                                                                                                       | 하드웨어 방식에 비해서는 속도가 낮고, 가격이 저렴하다.                                                     |
| 적용      | RISC 시스템                                                                                                                   | CISC 시스템                                                                                                |

##### 1.2.1.4. 기능

명령어와 데이터에 관련이 있다. 명령어 인출 및 해독은 모든 명령어에 대해 공통으로 수행해 기억 장치에서 명령어를 읽어온다. 데이터 인출 및 처리와 쓰기는 명령어가 필요 시 수행한다.

###### 1.2.1.4.1. 명령어

시스템이 특정 동작을 수행하는 가작 작은 단위이다. 코드로 이루어져있고, Op-code와 Operand가있다.

- Op-code: 동작코드로 각 명령어의 실행 동작을 구분해 표현한다.
- Operand: 명령어의 실행에 필요한 자료나 실제 자료의 주소를 의미한다.

###### 1.2.1.4.2. 명령어 수행과정

Operation을 처리하는 과정은 FI -> DI -> EI -> WB로 이뤄진다.

- Fetch Instruction(FI): 메모리에서 명령을 가져온다.
- Decode Instruction(DI): 명령을 해석한다.
- Excute Instruction(EI): 명령을 수행한다.
- Write Back(WB): 수행한 결과를 기록한다.

###### 1.2.1.4.3. 명령어 처리 방식

- Reduced Instruction Set Computer(RISC): 컴퓨터 내부에서 사용하는 명령어 세트를 단순화시켜 처리하는 구조이다. 단순한 명령을 조합해 하나의 기능을 수행한다.
  - 하나의 사이클로 명령어를 처리한다.
  - 메모리 Load/Store 명령만 처리한다.
  - 파이프라이닝, 슈퍼스칼라가 사용가능하다.
  - 복잡한 컴파일러 구조
- Complex Instruction Set Computer(CISC): 하나의 기능에 해당하는 하나의 명령이 있다.
  - 여러 사이클로 명령어 처리한다.
  - 많은 명령어가 메모리를 참조한다.
  - 파이프라이닝의 사용이 어렵다.
  - 복잡한 마이크로 프로그램 구조를 갖는다.

### 1.3. memory

메모리는 반도체로 이루어진 기억소자로 전류를 흐르게도하고 흐르지 않게도하여 임시적인 내용을 기억하게 만든다.

#### 1.3.1. 분류별 특성

보조 기억장치와 같이 저장소의 개념이지만, 휘발성으로 시스템이 활성화 된 상태에서만 그값을 기억하고, 시스템이 꺼지면 지워진다.

| 종류             | 저장용량 | 처리속도 | 가격 |
| ---------------- | -------- | -------- | ---- |
| register         | 적음     | 빠름     | 높음 |
| cache memory     | ↓        | ↑        | ↑    |
| main memory      | ↓        | ↑        | ↑    |
| auxiliary memory | 많음     | 느림     | 낮음 |

#### 1.3.2. 성능

메모리가 CPU와 데이터를 주고 받는 시간이다. access라고 하고, nano-second로 메모리 속도의 기준이된다.

- 리프레시 시간: 일정 시간마다 재충전을 하는데, 그렇지 않으면 정보는 휘발된다. 메모리에서 한번 읽고 나서 다시 읽수 있는 사이의 시간이다.
- 메모리 엑세스 시간: 데이터를 읽어오라는 명령을 받고 데이터를 읽기 시작하기까지의 시간이다. cpu에서 명령어를 처리할 때 명령어가 갖는 주소를 보낸다. cpu에 그 주소에 해당하는 값을 가져오는 시간이 액세스 시간이다.
- 사이클 시간(리프레시 + 메모리 액세스): 메모리의 작업이 완료와 동시에 대기 신호를 내놓은 후 다음 신호를 받을 준비가 되었다는 신호를 주기까지 시간을 말한다.

#### 1.3.3. 종류

##### 1.3.3.1. 주기억장치

- random access memory(ram): 휘발성으로 보조저장장치가 필수이다. 프래그램 수행 속도에 영향을 주며, cpu에서 접근이 가능한 유일한 저장장치이다.
- read only memory(rom): 대부분 읽을 수만 있는 장치로 전원이 끊겨도 내용이 보존된다.

##### 1.3.3.2. 보조기억장치

- 자기 디스크
  - 원판 표면의 철입자 방향(N/S)로 0과 1을 표현한다. 자기디스크로부터 데이터를 읽는 주변장치이다.
  - fdd와 hdd, 물리적 저장소이다.
- opical disk(od)
  - 광디스크는 빛의 반사로 자료를 읽는다.
  - cd에서 dvd, 블루레이까지 테라디스크나 HVD 등이 존재한다.
- 플래시 메모리
  - 전자적으로 데이터를 지우고 쓸 수 있는 비휘발성 메모리로 충격에 강하여 휴대용으로 이용한다.
  - usb, ssd가 있다. 기계적 장치는 빠지고 반도체로 저전력, 저소음, 저중량이라는 특징이 있으나, hhd와는 다르게 전력이 끊길 시 일부 데이터가 휘발한다.

### 1.4. cache memory

cpu내나 외에 존재하는 메모리로 메인 메모리와 cpu간 데이터 속도 향상을 위한 버퍼 역할을 한다. cpu와 메모리간의 속도차이를 보완하는 완충역할을 한다.

블록사이즈나 워즈 사이즈가 상대적으로 크면 그만큼 cache의 hit ratio율이 높아진다. 캐시 메모리가 메인 메모리의 일정 블록사이즈 데이터를 저장했다가 cpu에 워드 사이즈만큼 데이터를 전송한다. 이 사이즈가 캐시성능에 영향을 미친다.

cpu가 필요한 데이터가 cache memory 내 있으면 cache hit이다. 접근하고자 하는 데이터가 없는 것은 cache miss이다. cache가 있을 확율을 hit ratio라 한다.

| 요소                             | 내용                                                                                                                                    |
| -------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| cache크기                        | cache memory의 size크기가 크면 hit ratio율과 반비례 관계                                                                                |
| 인출 방식(fetch algorithm)       | 요구 인출(demand fetch): 필요 시 요구하여 인출한다                                                                                      |
|                                  | 선인출(pre-fetch): 예상되는 데이터를 미리 인출한다.                                                                                     |
| 쓰기 정책(write policy)          | write-through: 주기억장치와 캐시에 동시에 쓰는 방식이다. cache와 메모리의 내용이 항상 일치하고 구성방법은 단순하다.                     |
|                                  | write-back: 데이터 변경만 캐시에 기록하는 방식이다. 구성방법이 복잡하다.                                                                |
| 교체 알고리즘(replace algorithm) | cache miss 발생시 기존 메모리와 교체한다. fifo, lru, lfu, random, optimal belady's MIN(향후 가장 참조 되지 않을 블록을 교체) 등이 있다. |
| mapping 기법                     | 주 기억장치의 블록을 적자할 캐시 내에 위치를 지정한다. direct mapping, associative maping, set associative mapping 등이 있다.           |

## 2. 운영체제

hardware와 software간의 소통을 위해서는 운영체제가 필요하다.

### 2.1. 목적 및 기능

- 프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원관리
- 자원을 효율적으로 관리하기 위해 자원ㅢ 스케줄리 기능을 제공
- 유저와 시스템간의 인터페이스를 제공
- 시스템의 각종 하드웨어와 네트워크를 관리하고 제어

### 2.2. 시스템 자원 관리

- 프로세스 관리(cpu)
- 메모리 관리
- i/o관리

```
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ㅣOㅣUser programs     ㅣ
ㅣpㅣㅡㅡㅡㅡㅡㅡㅡㅡㅡ ㅣ
ㅣeㅣUser interface    ㅣ
ㅣrㅣㅡㅡㅡㅡㅡㅡㅡㅡ   ㅣ
ㅣaㅣSystem Calls      ㅣ
ㅣtㅣㅡㅡㅡㅡㅡㅡㅡㅡㅡ ㅣ
ㅣiㅣprogram control,  ㅣ
ㅣnㅣi/o,              ㅣ
ㅣgㅣfile system       ㅣ
ㅣ ㅣcomms             ㅣ
ㅣSㅣerror Mngt        ㅣ
ㅣyㅣresource          ㅣ
ㅣsㅣauditing          ㅣ
ㅣtㅣsecurity          ㅣ
ㅣeㅣ...               ㅣ
ㅣmㅣ                  ㅣ
ㅣㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ㅣHardware             ㅣ
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
```

#### 2.2.1. 응용 pg 관리

응용 pg가 실행되고, 시스템 자원을 사용할 수 있도록 권한과 사용자(user)를 관리한다.

ex) 웹캠 아무나 접근가능한 이슈

운영체제가 응용 pg를 사용하기위해 api를 제공한다. 시스템 자원을 사용할 수 있도록 운영체제 차원에서 다양한 함수를 제공하는 것을 시스템 콜(system call)이라고 한다.

## 3. 프로세스

프로그램이 실행중인 상태로 특정 메모리 공간에 프로그램의 코드가 적재되고 cpu가 해당 명령어를 하나씩 수행하고 있는 상태를 의미한다. os에서는 프로세스를 사용해 프로그램을 수행한다. 실행중인 하나의 애플리케이션을 프로세스라 한다. 사용자가 애플리케이션을 실행 시 os로부터 실행에 필요한 메모리를 할당받아 애플리케이션의 코드를 실행한다.

### 3.1. 구성요소

프로세스 구조체에는 프로세스마다 독립적으로 관리하는 유저 메모리 영역이나 프로세스가 사용하는 각종 객체들의 포인터를 관리하는 핸들 테이블이 있다.

1. Virtual Address Descriptors(유저 메모리 영역 관리): 각 프로세스별 독립된 영역, 유저 메모리 공간이다. 커널 메모리 공간의 경우 모든 프로세스가 공유하여 사용한다. 각 프로세스별 독립적 유저 메모리 영역을 관리하기 위해 Virtual Address Descriptors라는 관리 테이블이 있다.
2. Handle Table(핸들 테이블): 프로세스에서 사용하는 모든 핸들에 대한 커널 객체 포인터 정보를 배열 형태로 가지고 있는 공간이다. 프로세스가 종료하게 될 때 이 테이블의 정보를 참고하여 이 프로세서에서 사용하고 있는 모든 커널 객체를 자동으로 반환한다.
3. 독립적인 메모리 공간: 프로세스 단위로 관리되는 자원 중 가장 중요한 구별점은 가상 메모리이다. 페이징 기법을 이용하여 프로세스마다 별도의 고유한 메모리를 사용할 수 있게 하고 있다(윈도우 한정)

### 3.2. 특징

- 자원 소유의 단위: 각 프로세스는 자신의 실행 이미지 로드와 실행에 필요한 추가적인 메모리 공간을 가지고 있다. 메모리 공간은 각 프로세스마다 구별된다. 해당 프로세스가 접근하는 파일과 i/o장치들에 대해 프로세서 단위로 할당받아 관리된다.
- 디스패칭의 단위: 하나의 프로그램이 os로부터 cpu의 자원을 일정기간동안 할당 받아 명령어를 실행한다. os는 여러개의 프로세스가 병렬적으로 실행되게 하기 위해 cpu의 사용시간을 각 프로세스에 골고루 나누어준다. 하나의 프로세스에 여러개의 디스패칭 단위가 실행될 수 있도록 하고 있다. 이것을 스레드라고한다.

### 3.3. 상태

- run(실행): 프로세스가 프로세서를 차지하여 서비스를 받는 상태
- ready(준비): 실행될 수 있도록 준비되는 상태
- waiting(대기): cpu의 사용이 아니라 입출력의 사건을 기다리는 상태

### 3.4. processor와 process

> - processor
>   - hardware side: 프로그램을 수행하는 하드웨어 유닛 cpu이다. 하나 이상의 alu와 레지스터를 내장한다.
>   - software side: 데이터 포맷을 변환하는 역할을 수행하는 데이터 처리 시스템이다. 워드프로세서나 컴파일러 등
> - process
>   - 특정 목적을 수행하기 위해 나열된 작업의 목록을 의미한다. 메모리에 적재 되어 프로세서에 의해 실행중인 프로그램이다.

## 4. 스레드

명령어가 cpu를 통해 수행되는 객체의 단위이다. 하나의 프로세스 내에는 반드시 1개 이상의 스레드가 존재한다. 이 스레드는 같은 프로세스에 있는 자원과 상태를 공유한다.

같은 프로세스 내 있는 스레드는 같은 주소 공간에 존재한다. 하여 동일한 데이터에 접근가능하다. 하나의 스레드가 수정한 메모리는 같은 메모리를 찹조하는 스레드에 영향을 미친다.

하나의 프로세스 내에서 여러개의 루틴을 동시 수행 시 성능을 향상하려고 스레드를 사용한다. 독립적으로 수행하여 처리가능하다.

### 4.1. 구성요소

- 가상 cpu: 인터프리터, 컴파일러에 의해 내부적으로 처리되는 가상코드이다.
- 수행 코드: thread class에 구현되어 있는 run() method이다.
- 처리 데이터: thread에서 처리하는 데이터이다.

### 4.2. 특징

- 프로세스 내에서 실행되는 흐름의 단위이다. 하나의 스레드는 시작해서 종료시까지 한번에 하나씩 명령들을 수행한다.
- 각 스레드마다 call stack이 존재한다. 나머지 code, data, heap 영역은 스레드끼리 공유한다. 프로세스는 다른 프로세스의 메모리에 직접 접근불가하다.
- 스레드는 다른 스레드와 독립적으로 동작한다. 독립적으로 동작하기에 두개 이상의 스레드가 동작하는 경우 두개 이상의 스레드의 실행 및 종료순서는 예측할수없다.

### 4.3. 싱글스레드

단일 스레드로 동작하는 방식이다. 일련의 처리를 직렬처리하는 프로그래밍 방법이다. 하나의 레지스터, 스택으로 표현한다.

#### 4.3.1. 장점

- 자원 접근에 대한 동기화를 신경쓰지 않아도 된다. 여러 스레드가 프로세스의 자원을 공유할 시 각 스레드가 원하는 결과를 얻게 하려면 공용 자원에 대한 접근을 제어해야한다. 모든 스레가 일정 자원에 동시 접근하거나, 똑같은 작업을 실행하려는 경우, 에러가 발생하거나 원하는 값5이 나오지 않는다. 이에 스레드들이 동시에 같은 자원에 접근하지 못하도록 제어해야된다.
- 상기 이유로 context switch(문맥 교환)또한 필요없다. context switch는 여러 프로세스가 하나의 프로세서를 공유할때 발생하는 작업으로 많은 비용이 필요로한다.
- 프로그래밍 난이도가 쉽고, cpu메모리를 적게쓴다.

#### 4.3.2. 단점

- 여러 cpu를 활용 못한다. 물리코어가 하나이기에 멀티 코어 머신에서 cpu사용을 최적화가 안된다. 최적화를 위해 cluster모듈을 이용하여 여러 프로세스를 사용할 수 있지만, 프로세스끼리 자원공유가 어려워 redis같은 부가 인프라 사용으로 필요 비용이 증가한다.

### 4.4. 멀티 스레드

하나의 프로세스 내 둘이상의 스레드가 동시에 작업을 수행한다. 멀티 프로세스는 여러개의 cpu를 사용해 여러 프로세스를 동시에 수행한다.

#### 4.4.1. 장점

- 싱글의 경우 작업이 끝나기전 사용자에게 응답하지 않지만 작업을 분리하여 실시간으로 응답가능하다.
- 여러 프로세서로 나눠서 수행하므로 효율적이다.

#### 4.4.2. 단점

- 설계가 어렵고, 디버깅이 까다롭다.
- 단일 프로세스에서는 효과가 없고, 다른 프로세스에서 스레드를 제어할 수 없다.
- 자원공유 문제가 있다. 하나의 스레드에 문제가 생길 시 전체 프로세스가 영향을 받는다.
- context switch 작업이 필요하다. 다른 프로세스, 스레드가 시작할 수 있도록 이미 실행 중인 태스크를 멈춰야한다.

### 4.5. 동시성과 병렬성 차이

동시에 돌릴 수 있는 스레드 수는 기기에 있는 코어 개수로 제한된다. os는 각 스레드를 시간에 따라 분할하여 여러 스레드가 일정 시간마다 돌아가면서 실행되는 시분할을 한다.

- concurrency(동시성, 병행성): 여러 개의 스레드가 시분할 방식으로 동시에 수행되는 것처럼 착각을 일으킴
- parallelism(병렬성): 멀티 코어 환경에서 여러 개의 스레드가 실제로 동시에 수행

## 5. 문자열

프로그래밍 언어마다 문자열을 다루는 자료형이 다르다.

2010년 이후 통일된 인코딩방식인 unicode, unicode consortium이 제정한 전 세계의 모든 문자를 컴퓨터에 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준이다. ISO 10646 문자집합, 문자인코딩, 문자정보데이터베이스, 문자를 다루기위한 알고리즘을 포함한다.

인코딩은 프로그램이나 어떤 자료가아닌 단순히 어떤 문자나 기호를 컴퓨터가 이용할 수 있도록 신호로 만드는 것이다. 인코딩과 디코딩을 하기위한 표준을 정한 것을 문자열 charset이라고 한다. 이 국제 표준이 unicode이다.

ASCll는 영문 알파벳을 사용하는 대표적인 문자 인코딩으로 7bit로 모든 영어 알파벳을 표현할 수 있다. 52개의 영문 알파벳 대소문자와, 10개의 숫자, 32의 특수 문자, 하나의 공백문자를 포함한다.

unicode는 ASCll를 확장한 것이다.

UTF-8과 UTF-16은 Universal Coded Character Set + Transformation Format-8-bit의 약자로, UTF-뒤 등장하는 숫자는 bit이다.

- utf-8: 가변 길이 인코딩으로 문자하나에 1byte 8bits에서 4bytes까지 사용한다. 16진수 HEX로 표현 가능하며, binary number, 이진법으로 표현가능하다. 바이트 순서가 고정된다.
- ASCll: 7bits 표현되고, UTF-8에서는 1byte의 결과로 만들 수 있다.
- utf-16: 코드 그대로 바이트로 표현 가능하고, 바이트 순서가 다양하다. U+0000~U+FFFF; BMP를 16bits로 표현한다. 대부분은 2byte로 표현하지만 기타문자는 4bytes로 표현가능하므로 가변길이 이기도하다. byte순서, 엔디언에 따라 utf-16 종류가 달라진다.

## 6. 그래픽

bitmap, vector는 디지털 이미지의 종류이다. 디지털 이미지는 현실을 디지털의 형태로 표현한것을 말한다. 다른방식으로 표현하기에 bitmap과 vector는 차이가 있다.

bitmap은 픽셀단위로 이미지를 표현한다. 하여 계단현상, 꺠짐현상이 발생하고, 경계가 뚜렷하지 않다. 컴퓨터에는 부담이 덜가는 구조로 되어있고, 픽셀하나당 모두 색상값을 가진다. 하여 이미지가 커질수록 용량도 커진다.

vector는 수학적 공식으로 이미지를 표현한다. 계단현상이나 깨짐현상이 없고, 비트맵에 비해서는 컴퓨터에 부하를 주므로 도형, 글자 등을 그리는 작업에 사용한다. 수학 연산으로 만들기에 사이즈가 커져도 용량은 변화가 없다.

|                          | bitmap(raster)                                               | vector                                               |
| ------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- |
| 기술기반                 | 픽셀                                                         | 수학적 shape                                         |
| 특징                     | 사진과같이 색상의 조합이 다양한 이미지에 적합                | 로고, 일러스트와같이 제품에 적용되는 이미지          |
| 확대                     | 큰사이즈 이미지 필요 시 더 큰 사이즈로 생성하거나 스캔해야됨 | 품질저하없고, 모든 크기로 확대가능, 해상도 영향 없음 |
| dimentsion따른 file size | 큰 크기의 이미지, 큰 파일 사이즈                             | 큰 크기 벡터 그래픽 작은 사이즈 유지                 |
| 상호 변환                | 이미지 복잡도에따라 벡터로 변환에 시간이 걸림                | 쉽게 bitmap으로 변환가능                             |
| 확장명                   | jpg, gif, png, bmp, psd 등                                   | svg, ai 등                                           |

## 7. 가비지 컬렉션 캐시

low level language인 기계어, 어셈블리어, c같은 경우는 메모리를 직접잡고 풀어주어야한다. 하지만 high level language인 현대의 언어들인 c#, java, javascript, python 등은 메모리를 가비지 컬렉션이 내장되어 제어해준다.

### 7.1. 메모리 생존주기

1. 필요시 개발자가 할당한다.
2. 할당된 메모리 사용
3. 메모리 필요없으면 해제

#### 7.1.1. 할당

선언하면 자동으로 메모리를 할당해준다.

#### 7.1.2. 사용

선언으로 자동할당된 메모리, 선언한 변수나 객체를 불러오거나 쓰거나할시 일어난다.

#### 7.1.3. 해제

가비지 컬렉션이 메모리 할당을 추적하고, 할당된 메모리 블록이 더이상 필요하지 않게 되었는지 스스로 판단하여 필요하지 않으면 메모리를 해제한다. 필요의 여부는 비결정적인 영역이어 제한적 해결책을 구현한다. ex: java 해당된 메모리와의 연결이 끊어질 시

### 7.2. 방법

- reference: 메모리 관리 관점에서 어떤 객체가 다른 객체에 접근할 수 있드면, 다른 객체를 참조한다. javascript의 prototype에대한 암묵적 참조, 자신의 property에 대한 명시적 참조를 갖는다.
- scope: 광의적 개념으로 function scope나 global lexical scope까지 포함한다.
- lexical scoping: 변수 이름이 중첩된 함수에서 해석되는 방식이다. 중첩되어 있는 안쪽 함수는 부모 함수가 값을 반환한 다음에도 부모 함수의 스코프를 포함한다.

#### 7.2.1. 레퍼런스 카운팅

참조가 복사될때마다 카운트를 올리고, 변수의 값이 변경되거나, 스코프가 끝나면 카운트를 줄인다. 0이되면 가비지컬렉터가 돈다. 하지만 서로를 바라보는 객체가 있다면, 스코프를 끝나면 메모리는 반환되지만, 레퍼런스 카운팅 알고리즘에서는 한번 참조한 값이 남게되어 가비지 컬렉터가 돌지않는다.

#### 7.2.2. 트레이싱

객체에 flag를 두고, 가비지 컬렉션 사이클마다 flag에 표시 후 삭제하는 mark and sweep방법이다. 객체에 in-use flag를 두고, 사이클마다 메모리 관리자가 모든 객체를 추적해서 사용 중인지 아닌지를 마크한다. 그 후 표시되지 않은 객체를 sweep하는 단계를 통해 메모리를 해제한다. 대부분의 가비지 컬렉션이 mark and sweep을 사용한다.

1. 객체가 필요한가에 대하여 닿을 수 있는지 reachable을 판단한다.
2. root: 코드에서 참조되는 전역 변수이다. js: window, nodejs: global, 가비지 컬렉터는 모든 루트의 완전한 목록을 만든다.
3. 모든 루트와 그 자식들을 검사해 활성화 여부를 표시한다.(활성상태면 가비지가 아니다.) 루트가 닿을 수 없는 것들은 가비지로 표시된다.
4. 마지막으로 가비지컬렉터는 활성으로 표시되지 않은 모든 메모리를 os에 반환한다.

참조받지 않는 객체는 닿을 수 없는 객체기에 가비지 컬렉션을 통해 메모리를 해제할 수 있다.

### 7.3. 메모리 누수

주요원인은 우리이다. 예상치 못한 참조로 우발적으로 생성된 전역변수라던가, dom 외부에서 참조, closer의 잘못된 사용을 들 수 있다.

---

양은 어마어마한데 필요하다 필요해

---

## 참조

> [codex: os10, operating system concepts](https://codex.cs.yale.edu/avi/os-book/OS10/index.html)  
> [github: parksb, 명령 시스템 컨셉 한글 정리 문서](https://parksb.github.io/article/5.html)  
> [나무위키: deadlock](https://namu.wiki/w/%EB%8D%B0%EB%93%9C%EB%9D%BD)  
> [worth-spreading: mutex & semaphore](https://worthpreading.tistory.com/90)  
> [나무위키: mutex](https://namu.wiki/w/%EB%AE%A4%ED%85%8D%EC%8A%A4)  
> [나무위키: semaphore](https://namu.wiki/w/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4)  
> [wiki: raster graphics](https://ko.wikipedia.org/wiki/%EB%9E%98%EC%8A%A4%ED%84%B0_%EA%B7%B8%EB%9E%98%ED%94%BD%EC%8A%A4)  
> [wiki: low level language](https://ko.wikipedia.org/wiki/%EC%A0%80%EA%B8%89_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4)  
> [wiki: high level language](https://ko.wikipedia.org/wiki/%EA%B3%A0%EA%B8%89_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4)  
> [mdn: event loop](https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop)  
> [html: event loop](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops)  
> [nodejs: event loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop)
